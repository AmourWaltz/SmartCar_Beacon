###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       21/May/2018  00:37:57
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\app\device\src\camera_image.c
#    Command line =  
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\app\device\src\camera_image.c
#        -D LPLD_K60 -lCN
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\RAM\List -lB
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\RAM\List -o
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\RAM\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\ -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\CPU\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\common\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\LPLD\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\FatFs\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\USB\common\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\..\..\lib\USB\class\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\control\inc\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\control\src\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\debug\inc\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\debug\src\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\device\inc\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\device\src\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\driver\inc\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\driver\src\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\signal\inc\
#        -I
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\signal\src\
#        -I D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\..\app\system\
#        -Ol -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\RAM\List\camera_image.lst
#    Object file  =  
#        D:\Freescale\信标\13thBeacon\project\Beacon_XBY\iar\RAM\Obj\camera_image.o
#
###############################################################################

D:\Freescale\信标\13thBeacon\project\Beacon_XBY\app\device\src\camera_image.c
      1          /*
      2          File name:CYP_camera.c
      3          programmer: Chen Yinpeng
      4          Version:1.0(2018/2/24)
      5          Notice:
      6          大致思路：
      7          .初始化摄像头（初始化DMA和GPIO和中断）
      8          .需要采集图像时，打开场中断允许
      9          .当一个场中断来临时，开启行中断允许
     10          .进入行中断后，开启DMA硬件请求
     11          .通过PCLK的下降沿传输DMA，传输完固定的字节数后DMA自动关闭硬件请求
     12          .再次进入行中断，开启DMA硬件请求
     13          .....
     14          .再次进入场中断，对接收到的图像数据进行处理
     15          .进入行中断，开启DMA硬件请求
     16          .....
     17          程序优化总结：
     18          优化基本思想：人脑代替计算机适当的计算，自己想的多了，计算机就想的少了
     19          优化基本技巧：一些不在程序中改变的数据，尽量做出来表查表运算
     20                       减少内循环循环判断次数，比如i++变为i+=2，循环展开（效果显著，但程序兼容性下降）
     21                       能使用位运算尽量使用位运算
     22                       除法和取模运算尽量不用
     23                       重复的运算应使用一个临时变量来代替
     24          优化缺点：造成程序可度性下降，兼容性下降，牺牲更多的空间
     25          
     26          摄像头调试教训：
     27          1.优先级问题，尤其是涉及到按位运算时
     28          2.中断保证，尤其是GPIO中断时，一定要保证是指定的引脚产生的中断，可以滤掉杂波
     29          3.多一个保证就少一个隐患，不要为了程序简洁而去除一些自以为不重要的语句
     30          */
     31          
     32          #include "include.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable9  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable9_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     33          
     34          extern uint8 gl_LeftEdge[IMAGE_HEIGHT];//全局左侧边沿数组
     35          extern uint8 gl_RightEdge[IMAGE_HEIGHT];//全局右侧边沿数组
     36          

   \                                 In section .bss, align 4
     37          uint8 gl_Image0[CAMERA_SIZE]; 
   \                     gl_Image0:
   \   00000000                      DS8 9600

   \                                 In section .bss, align 4
     38          uint8 gl_Image1[CAMERA_SIZE];//初始未解压存储空间
   \                     gl_Image1:
   \   00000000                      DS8 9600

   \                                 In section .bss, align 4
     39          uint8 gl_ImageFull[CAMERA_W * CAMERA_H];//储存所有像素点的数组
   \                     gl_ImageFull:
   \   00000000                      DS8 76800

   \                                 In section .bss, align 4
     40          uint8 gl_ImageCompress[IMAGE_HEIGHT][IMAGE_WIDTH];//储存图像的最终数组
   \                     gl_ImageCompress:
   \   00000000                      DS8 8192

   \                                 In section .bss, align 1
     41          static uint8 gl_now_flag = 0;//目前正在纯属的图像标志
   \                     gl_now_flag:
   \   00000000                      DS8 1
     42          

   \                                 In section .bss, align 1
     43          boolean gl_running = FALSE;//小车正在跑的标志
   \                     gl_running:
   \   00000000                      DS8 1
     44          
     45          static uint16 g_row[IMAGE_WIDTH]=
     46          {
     47          88,92,96,100,103,107,110,114,117,119,
     48          123,126,129,132,134,137,140,143,147,150,
     49          153,155,158,161,164,166,169,172,
     50          175,177,180,182,185,187,190,192,
     51          195,197,200,202,205,207,209,212,
     52          214,217,219,221,223,226,228,230,
     53          232,234,236,238,240,242,244,246,
     54          248,250,252,254
     55          };//比较好的取行
     56          
     57          //取行数组

   \                                 In section .bss, align 4
     58          uint16 gl_row[IMAGE_HEIGHT];
   \                     gl_row:
   \   00000000                      DS8 128
     59          
     60          //取列数组（以160列为基准）

   \                                 In section .bss, align 4
     61          uint16 gl_RowCol[IMAGE_HEIGHT][IMAGE_WIDTH];
   \                     gl_RowCol:
   \   00000000                      DS8 16384
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void Camera_Init()
     64          {
   \                     Camera_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     65             Camera_GPIO_Init();
   \   00000002   0x.... 0x....      BL       Camera_GPIO_Init
     66             Camera_DMA_Init();
   \   00000006   0x.... 0x....      BL       Camera_DMA_Init
     67             ov7725_eagle_init();
   \   0000000A   0x.... 0x....      BL       ov7725_eagle_init
     68             Matrix_Init();//提取数组初始化
   \   0000000E   0x.... 0x....      BL       Matrix_Init
     69          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
     70          
     71          //void Matrix_Init()
     72          //{
     73          //   uint16 i, j;
     74          //   
     75          //   for (i = 0; i < IMAGE_HEIGHT; i++)
     76          //   {
     77          //      gl_row[i] = (uint16)(ROW_START + i * i * 0.025 + 1.76 * i);
     78          //      for (j = 0; j < IMAGE_WIDTH; j++)
     79          //      {
     80          //         gl_RowCol[i][j] = COLUMN_START + j * COLUMN_NUM / IMAGE_WIDTH;
     81          //      }
     82          //      if (i > 0 && i < IMAGE_HEIGHT / 4)//远处
     83          //      {
     84          //         gl_ImageWeight[i] = gl_weight4;
     85          //      }
     86          //      else if (i > IMAGE_HEIGHT / 4 && i < IMAGE_HEIGHT / 2)
     87          //      {
     88          //         gl_ImageWeight[i] = gl_weight3;
     89          //      }
     90          //      else if (i > IMAGE_HEIGHT / 2 && i < IMAGE_HEIGHT * 3 / 4)
     91          //      {
     92          //         gl_ImageWeight[i] = gl_weight2;
     93          //      }
     94          //      else
     95          //      {
     96          //         gl_ImageWeight[i] = gl_weight1;
     97          //      }
     98          //   }
     99          //}
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void Camera_GPIO_Init()
    102          {
   \                     Camera_GPIO_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    103             //行中断信号初始化
    104             GPIO_InitTypeDef GPIO_init;
    105             GPIO_init.GPIO_PTx = H_GPIO_PORT;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400ff080
   \   00000008   0x9001             STR      R0,[SP, #+4]
    106             GPIO_init.GPIO_Pins = H_PIN;
   \   0000000A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000000E   0x9002             STR      R0,[SP, #+8]
    107             GPIO_init.GPIO_Dir = DIR_INPUT;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0010      STRB     R0,[SP, #+16]
    108             GPIO_init.GPIO_PinControl = IRQC_RI | INPUT_PULL_DOWN | INPUT_PF_EN;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x90012
   \   0000001A   0x9003             STR      R0,[SP, #+12]
    109             GPIO_init.GPIO_Output = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0011      STRB     R0,[SP, #+17]
    110             GPIO_init.GPIO_Isr = Camera_H_Isr;
   \   00000022   0x.... 0x....      ADR.W    R0,Camera_H_Isr
   \   00000026   0x9005             STR      R0,[SP, #+20]
    111             LPLD_GPIO_Init(GPIO_init);
   \   00000028   0xA901             ADD      R1,SP,#+4
   \   0000002A   0xB084             SUB      SP,SP,#+16
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x2214             MOVS     R2,#+20
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000034   0xBC0F             POP      {R0-R3}
   \   00000036   0x.... 0x....      BL       LPLD_GPIO_Init
    112             //场中断信号初始化
    113             GPIO_init.GPIO_PTx = V_GPIO_PORT;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x400ff080
   \   0000003E   0x9001             STR      R0,[SP, #+4]
    114             GPIO_init.GPIO_Pins = V_PIN;
   \   00000040   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000044   0x9002             STR      R0,[SP, #+8]
    115             GPIO_init.GPIO_Dir = DIR_INPUT;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0010      STRB     R0,[SP, #+16]
    116             GPIO_init.GPIO_PinControl = IRQC_RI | INPUT_PULL_DOWN | INPUT_PF_EN;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x90012
   \   00000050   0x9003             STR      R0,[SP, #+12]
    117             GPIO_init.GPIO_Output = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF88D 0x0011      STRB     R0,[SP, #+17]
    118             GPIO_init.GPIO_Isr = Camera_V_Isr;
   \   00000058   0x.... 0x....      ADR.W    R0,Camera_V_Isr
   \   0000005C   0x9005             STR      R0,[SP, #+20]
    119             LPLD_GPIO_Init(GPIO_init);
   \   0000005E   0xA901             ADD      R1,SP,#+4
   \   00000060   0xB084             SUB      SP,SP,#+16
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x2214             MOVS     R2,#+20
   \   00000066   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000006A   0xBC0F             POP      {R0-R3}
   \   0000006C   0x.... 0x....      BL       LPLD_GPIO_Init
    120             //数据信号初始化
    121             GPIO_init.GPIO_PTx = DATA_GPIO_PORT;
   \   00000070   0x....             LDR.N    R0,??DataTable9_4  ;; 0x400ff0c0
   \   00000072   0x9001             STR      R0,[SP, #+4]
    122             GPIO_init.GPIO_Pins = DATA_PIN;
   \   00000074   0x20FF             MOVS     R0,#+255
   \   00000076   0x9002             STR      R0,[SP, #+8]
    123             GPIO_init.GPIO_Dir = DIR_INPUT;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF88D 0x0010      STRB     R0,[SP, #+16]
    124             GPIO_init.GPIO_PinControl = IRQC_DIS | INPUT_PULL_DOWN | INPUT_PF_EN;//为什么还要无源滤波？
   \   0000007E   0x2012             MOVS     R0,#+18
   \   00000080   0x9003             STR      R0,[SP, #+12]
    125             GPIO_init.GPIO_Output = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF88D 0x0011      STRB     R0,[SP, #+17]
    126             GPIO_init.GPIO_Isr = NULL;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x9005             STR      R0,[SP, #+20]
    127             LPLD_GPIO_Init(GPIO_init);
   \   0000008C   0xA901             ADD      R1,SP,#+4
   \   0000008E   0xB084             SUB      SP,SP,#+16
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x2214             MOVS     R2,#+20
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000098   0xBC0F             POP      {R0-R3}
   \   0000009A   0x.... 0x....      BL       LPLD_GPIO_Init
    128             //PCLK信号初始化
    129             GPIO_init.GPIO_PTx = PCLK_GPIO_PORT;
   \   0000009E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x400ff080
   \   000000A0   0x9001             STR      R0,[SP, #+4]
    130             GPIO_init.GPIO_Pins = PCLK_PIN;
   \   000000A2   0xF45F 0x2000      MOVS     R0,#+524288
   \   000000A6   0x9002             STR      R0,[SP, #+8]
    131             GPIO_init.GPIO_Dir = DIR_INPUT;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF88D 0x0010      STRB     R0,[SP, #+16]
    132             GPIO_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_DOWN | INPUT_PF_EN;//为什么还要无源滤波？
   \   000000AE   0x....             LDR.N    R0,??DataTable9_5  ;; 0x20012
   \   000000B0   0x9003             STR      R0,[SP, #+12]
    133             GPIO_init.GPIO_Output = 0;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF88D 0x0011      STRB     R0,[SP, #+17]
    134             GPIO_init.GPIO_Isr = NULL;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x9005             STR      R0,[SP, #+20]
    135             LPLD_GPIO_Init(GPIO_init);
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0xB084             SUB      SP,SP,#+16
   \   000000C0   0x4668             MOV      R0,SP
   \   000000C2   0x2214             MOVS     R2,#+20
   \   000000C4   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000C8   0xBC0F             POP      {R0-R3}
   \   000000CA   0x.... 0x....      BL       LPLD_GPIO_Init
    136             
    137          }
   \   000000CE   0xB007             ADD      SP,SP,#+28
   \   000000D0   0xBD00             POP      {PC}             ;; return
    138          

   \                                 In section .text, align 2, keep-with-next
    139          void Camera_DMA_Init()
    140          {
   \                     Camera_DMA_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    141             static DMA_InitTypeDef DMA_init;
    142             DMA_init.DMA_CHx = DMA_CHX;//通道
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable9_6
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    143             DMA_init.DMA_Req = DMA_REQ;//DMA请求源
   \   0000000A   0x2033             MOVS     R0,#+51
   \   0000000C   0x....             LDR.N    R1,??DataTable9_6
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
    144             DMA_init.DMA_PeriodicTriggerEnable = FALSE; //PIT周期触发关闭
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable9_6
   \   00000014   0x7088             STRB     R0,[R1, #+2]
    145             
    146             DMA_init.DMA_MajorLoopCnt = DMA_MAJOR_LOOP;//主循环次数
   \   00000016   0x2028             MOVS     R0,#+40
   \   00000018   0x....             LDR.N    R1,??DataTable9_6
   \   0000001A   0x8088             STRH     R0,[R1, #+4]
    147             DMA_init.DMA_MinorByteCnt = DMA_MINER_BYTE;//副循环一次传输字节数
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable9_6
   \   00000020   0x6088             STR      R0,[R1, #+8]
    148             
    149             DMA_init.DMA_SourceAddr = DMA_SOURCE_ADDR;//传输源地址
   \   00000022   0x....             LDR.N    R0,??DataTable9_7  ;; 0x400ff0d0
   \   00000024   0x....             LDR.N    R1,??DataTable9_6
   \   00000026   0x60C8             STR      R0,[R1, #+12]
    150             DMA_init.DMA_DestAddr = DMA_DEST_ADDR;//传输目的地址
   \   00000028   0x....             LDR.N    R0,??DataTable9_8
   \   0000002A   0x....             LDR.N    R1,??DataTable9_6
   \   0000002C   0x6188             STR      R0,[R1, #+24]
    151             
    152             DMA_init.DMA_SourceDataSize = DMA_SOURCE_DATA_SIZE;//源数据传输宽度
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable9_6
   \   00000032   0x7408             STRB     R0,[R1, #+16]
    153             DMA_init.DMA_SourceAddrOffset = DMA_SOURCE_ADDR_OFFSET;//源地址读取后偏移量
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable9_6
   \   00000038   0x8248             STRH     R0,[R1, #+18]
    154             DMA_init.DMA_DestDataSize = DMA_DEST_DATA_SIZE;//目的数据传输宽度
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable9_6
   \   0000003E   0x7708             STRB     R0,[R1, #+28]
    155             DMA_init.DMA_DestAddrOffset = DMA_DEST_ADDR_OFFSET;//目的地址写入后偏移量
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable9_6
   \   00000044   0x83C8             STRH     R0,[R1, #+30]
    156             DMA_init.DMA_AutoDisableReq = TRUE;    //自动禁用请求
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable9_6
   \   0000004A   0xF881 0x0024      STRB     R0,[R1, #+36]
    157             
    158             LPLD_DMA_Init(DMA_init);
   \   0000004E   0x....             LDR.N    R1,??DataTable9_6
   \   00000050   0xB084             SUB      SP,SP,#+16
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x222C             MOVS     R2,#+44
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000005A   0xBC0F             POP      {R0-R3}
   \   0000005C   0x.... 0x....      BL       LPLD_DMA_Init
    159             LPLD_DMA_DisableReq(DMA_CHX);//禁用硬件请求DMA
   \   00000060   0x....             LDR.N    R0,??DataTable9_9  ;; 0x4000800c
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x0040             LSLS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable9_9  ;; 0x4000800c
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    160             
    161          }
   \   0000006C   0xB007             ADD      SP,SP,#+28
   \   0000006E   0xBD00             POP      {PC}             ;; return

   \                                 In section .bss, align 4
   \                     `Camera_DMA_Init::DMA_init`:
   \   00000000                      DS8 44
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void Camera_Start()
    164          {
   \                     Camera_Start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    165             enable_irq(V_PORT_IRQn);//开启场中断
   \   00000002   0x2059             MOVS     R0,#+89
   \   00000004   0x.... 0x....      BL       NVIC_EnableIRQ
    166             enable_irq(H_PORT_IRQn);//开启行中断
   \   00000008   0x2059             MOVS     R0,#+89
   \   0000000A   0x.... 0x....      BL       NVIC_EnableIRQ
    167             enable_irq(Reserved110_IRQn);//开启软件中断
   \   0000000E   0x205E             MOVS     R0,#+94
   \   00000010   0x.... 0x....      BL       NVIC_EnableIRQ
    168             gl_running = TRUE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable9_10
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    169          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    170          

   \                                 In section .text, align 2, keep-with-next
    171          void Camera_Close()
    172          {
   \                     Camera_Close: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    173             disable_irq(V_PORT_IRQn);//关闭场中断
   \   00000002   0x2059             MOVS     R0,#+89
   \   00000004   0x.... 0x....      BL       NVIC_DisableIRQ
    174             disable_irq(H_PORT_IRQn);//关闭行中断
   \   00000008   0x2059             MOVS     R0,#+89
   \   0000000A   0x.... 0x....      BL       NVIC_DisableIRQ
    175             disable_irq(Reserved110_IRQn);//关闭软件中断
   \   0000000E   0x205E             MOVS     R0,#+94
   \   00000010   0x.... 0x....      BL       NVIC_DisableIRQ
    176          //   LPLD_DMA_DisableReq(DMA_CHX);//关闭DMA请求
    177             gl_running = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable9_10
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    178          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    179          
    180          /*
    181          函数参数:  dst:目的地址
    182                     src:源地址
    183                     size:解压的字节数
    184          函数功能: 将源地址的图像解压为0,1，图像字节数必须是4的倍数！！！
    185          函数时间：2.3~2.4ms
    186          函数已优化
    187          */

   \                                 In section .text, align 2, keep-with-next
    188          void Img_Extract(uint8 *src, uint8 *dst, uint32 size)
    189          {
   \                     Img_Extract: (+1)
   \   00000000   0xB410             PUSH     {R4}
    190              register uint8 src_tmp;
    191              size = size - (size % 4); //取四的倍数
   \   00000002   0xF012 0x0303      ANDS     R3,R2,#0x3
   \   00000006   0x1AD2             SUBS     R2,R2,R3
   \   00000008   0xE06E             B.N      ??Img_Extract_0
    192              
    193              while(size)
    194              {
    195                  src_tmp = ~(*src);
   \                     ??Img_Extract_1: (+1)
   \   0000000A   0x7803             LDRB     R3,[R0, #+0]
   \   0000000C   0x43DC             MVNS     R4,R3
    196                  *dst = (src_tmp >> 7 ) & 0x01;
   \   0000000E   0x0023             MOVS     R3,R4
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x09DB             LSRS     R3,R3,#+7
   \   00000014   0x700B             STRB     R3,[R1, #+0]
    197                  *(dst + 1 ) = (src_tmp >> 6 ) & 0x01;
   \   00000016   0xF3C4 0x1380      UBFX     R3,R4,#+6,#+1
   \   0000001A   0x704B             STRB     R3,[R1, #+1]
    198                  *(dst + 2 ) = (src_tmp >> 5 ) & 0x01;
   \   0000001C   0xF3C4 0x1340      UBFX     R3,R4,#+5,#+1
   \   00000020   0x708B             STRB     R3,[R1, #+2]
    199                  *(dst + 3 ) = (src_tmp >> 4 ) & 0x01;
   \   00000022   0xF3C4 0x1300      UBFX     R3,R4,#+4,#+1
   \   00000026   0x70CB             STRB     R3,[R1, #+3]
    200                  *(dst + 4 ) = (src_tmp >> 3 ) & 0x01;
   \   00000028   0xF3C4 0x03C0      UBFX     R3,R4,#+3,#+1
   \   0000002C   0x710B             STRB     R3,[R1, #+4]
    201                  *(dst + 5 ) = (src_tmp >> 2 ) & 0x01;
   \   0000002E   0xF3C4 0x0380      UBFX     R3,R4,#+2,#+1
   \   00000032   0x714B             STRB     R3,[R1, #+5]
    202                  *(dst + 6 ) = (src_tmp >> 1 ) & 0x01;
   \   00000034   0xF3C4 0x0340      UBFX     R3,R4,#+1,#+1
   \   00000038   0x718B             STRB     R3,[R1, #+6]
    203                  *(dst + 7 ) = (src_tmp >> 0 ) & 0x01;
   \   0000003A   0xF014 0x0301      ANDS     R3,R4,#0x1
   \   0000003E   0x71CB             STRB     R3,[R1, #+7]
    204                  
    205                  src_tmp = ~(*(src + 1));
   \   00000040   0x7843             LDRB     R3,[R0, #+1]
   \   00000042   0x43DC             MVNS     R4,R3
    206                  *(dst + 8 ) = (src_tmp >> 7 ) & 0x01;
   \   00000044   0x0023             MOVS     R3,R4
   \   00000046   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000048   0x09DB             LSRS     R3,R3,#+7
   \   0000004A   0x720B             STRB     R3,[R1, #+8]
    207                  *(dst + 9 ) = (src_tmp >> 6 ) & 0x01;
   \   0000004C   0xF3C4 0x1380      UBFX     R3,R4,#+6,#+1
   \   00000050   0x724B             STRB     R3,[R1, #+9]
    208                  *(dst + 10 ) = (src_tmp >> 5 ) & 0x01;
   \   00000052   0xF3C4 0x1340      UBFX     R3,R4,#+5,#+1
   \   00000056   0x728B             STRB     R3,[R1, #+10]
    209                  *(dst + 11 ) = (src_tmp >> 4 ) & 0x01;
   \   00000058   0xF3C4 0x1300      UBFX     R3,R4,#+4,#+1
   \   0000005C   0x72CB             STRB     R3,[R1, #+11]
    210                  *(dst + 12 ) = (src_tmp >> 3 ) & 0x01;
   \   0000005E   0xF3C4 0x03C0      UBFX     R3,R4,#+3,#+1
   \   00000062   0x730B             STRB     R3,[R1, #+12]
    211                  *(dst + 13 ) = (src_tmp >> 2 ) & 0x01;
   \   00000064   0xF3C4 0x0380      UBFX     R3,R4,#+2,#+1
   \   00000068   0x734B             STRB     R3,[R1, #+13]
    212                  *(dst + 14 ) = (src_tmp >> 1 ) & 0x01;
   \   0000006A   0xF3C4 0x0340      UBFX     R3,R4,#+1,#+1
   \   0000006E   0x738B             STRB     R3,[R1, #+14]
    213                  *(dst + 15 ) = (src_tmp >> 0 ) & 0x01;//2个字节
   \   00000070   0xF014 0x0301      ANDS     R3,R4,#0x1
   \   00000074   0x73CB             STRB     R3,[R1, #+15]
    214                  
    215                  src_tmp = ~(*(src + 2));
   \   00000076   0x7883             LDRB     R3,[R0, #+2]
   \   00000078   0x43DC             MVNS     R4,R3
    216                  *(dst + 16) = (src_tmp >> 7 ) & 0x01; 
   \   0000007A   0x0023             MOVS     R3,R4
   \   0000007C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000007E   0x09DB             LSRS     R3,R3,#+7
   \   00000080   0x740B             STRB     R3,[R1, #+16]
    217                  *(dst + 17) = (src_tmp >> 6 ) & 0x01;
   \   00000082   0xF3C4 0x1380      UBFX     R3,R4,#+6,#+1
   \   00000086   0x744B             STRB     R3,[R1, #+17]
    218                  *(dst + 18) = (src_tmp >> 5 ) & 0x01;
   \   00000088   0xF3C4 0x1340      UBFX     R3,R4,#+5,#+1
   \   0000008C   0x748B             STRB     R3,[R1, #+18]
    219                  *(dst + 19) = (src_tmp >> 4 ) & 0x01;
   \   0000008E   0xF3C4 0x1300      UBFX     R3,R4,#+4,#+1
   \   00000092   0x74CB             STRB     R3,[R1, #+19]
    220                  *(dst + 20) = (src_tmp >> 3 ) & 0x01;
   \   00000094   0xF3C4 0x03C0      UBFX     R3,R4,#+3,#+1
   \   00000098   0x750B             STRB     R3,[R1, #+20]
    221                  *(dst + 21) = (src_tmp >> 2 ) & 0x01;
   \   0000009A   0xF3C4 0x0380      UBFX     R3,R4,#+2,#+1
   \   0000009E   0x754B             STRB     R3,[R1, #+21]
    222                  *(dst + 22) = (src_tmp >> 1 ) & 0x01;
   \   000000A0   0xF3C4 0x0340      UBFX     R3,R4,#+1,#+1
   \   000000A4   0x758B             STRB     R3,[R1, #+22]
    223                  *(dst + 23) = (src_tmp >> 0 ) & 0x01;
   \   000000A6   0xF014 0x0301      ANDS     R3,R4,#0x1
   \   000000AA   0x75CB             STRB     R3,[R1, #+23]
    224                  
    225                  src_tmp = ~(*(src + 3));
   \   000000AC   0x78C3             LDRB     R3,[R0, #+3]
   \   000000AE   0x43DC             MVNS     R4,R3
    226                  *(dst + 24) = (src_tmp >> 7 ) & 0x01;
   \   000000B0   0x0023             MOVS     R3,R4
   \   000000B2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000B4   0x09DB             LSRS     R3,R3,#+7
   \   000000B6   0x760B             STRB     R3,[R1, #+24]
    227                  *(dst + 25) = (src_tmp >> 6 ) & 0x01;
   \   000000B8   0xF3C4 0x1380      UBFX     R3,R4,#+6,#+1
   \   000000BC   0x764B             STRB     R3,[R1, #+25]
    228                  *(dst + 26) = (src_tmp >> 5 ) & 0x01;
   \   000000BE   0xF3C4 0x1340      UBFX     R3,R4,#+5,#+1
   \   000000C2   0x768B             STRB     R3,[R1, #+26]
    229                  *(dst + 27) = (src_tmp >> 4 ) & 0x01;
   \   000000C4   0xF3C4 0x1300      UBFX     R3,R4,#+4,#+1
   \   000000C8   0x76CB             STRB     R3,[R1, #+27]
    230                  *(dst + 28) = (src_tmp >> 3 ) & 0x01;
   \   000000CA   0xF3C4 0x03C0      UBFX     R3,R4,#+3,#+1
   \   000000CE   0x770B             STRB     R3,[R1, #+28]
    231                  *(dst + 29) = (src_tmp >> 2 ) & 0x01;
   \   000000D0   0xF3C4 0x0380      UBFX     R3,R4,#+2,#+1
   \   000000D4   0x774B             STRB     R3,[R1, #+29]
    232                  *(dst + 30) = (src_tmp >> 1 ) & 0x01;
   \   000000D6   0xF3C4 0x0340      UBFX     R3,R4,#+1,#+1
   \   000000DA   0x778B             STRB     R3,[R1, #+30]
    233                  *(dst + 31) = (src_tmp >> 0 ) & 0x01;//4个字节
   \   000000DC   0xF014 0x0301      ANDS     R3,R4,#0x1
   \   000000E0   0x77CB             STRB     R3,[R1, #+31]
    234                  
    235                  src += 4;
   \   000000E2   0x1D00             ADDS     R0,R0,#+4
    236                  dst += 32;
   \   000000E4   0x3120             ADDS     R1,R1,#+32
    237                  size -= 4;
   \   000000E6   0x1F12             SUBS     R2,R2,#+4
    238              }
   \                     ??Img_Extract_0: (+1)
   \   000000E8   0x2A00             CMP      R2,#+0
   \   000000EA   0xD18E             BNE.N    ??Img_Extract_1
    239          }
   \   000000EC   0xBC10             POP      {R4}
   \   000000EE   0x4770             BX       LR               ;; return
    240          
    241          /*
    242          图像压缩为128行64列（利用提取数组）
    243          函数参数:  image:目的地址
    244                     src:解压后的源地址
    245          函数时间：1.7~1.8ms
    246          注意：图像的宽度必须为4的倍数！！！
    247          */

   \                                 In section .text, align 2, keep-with-next
    248          void Img_Compress_128x64(uint8 *src, uint8 (*image)[IMAGE_WIDTH])
    249          {
   \                     Img_Compress_128x64: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    250             register uint16 i, j;
    251             const uint8 *p = NULL;//位置指针
   \   00000002   0x2400             MOVS     R4,#+0
    252             
    253             for (i = 0; i < IMAGE_HEIGHT; i++)//图像上下左右颠倒
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xE052             B.N      ??Img_Compress_128x64_0
    254             {
    255                p = src + gl_row[i] * CAMERA_W;//位置指针移动
    256                for (j = 0; j < IMAGE_WIDTH; j += 4)//为程序效率考虑，内循环适当展开
    257                {
    258                   image[i][j] = *(p + gl_RowCol[i][j]);
   \                     ??Img_Compress_128x64_1: (+1)
   \   00000008   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   0x2580             MOVS     R5,#+128
   \   0000000C   0xFB05 0xF502      MUL      R5,R5,R2
   \   00000010   0x440D             ADD      R5,R1,R5
   \   00000012   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000014   0x....             LDR.N    R6,??DataTable9_11
   \   00000016   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000018   0xF44F 0x7780      MOV      R7,#+256
   \   0000001C   0xFB07 0xF702      MUL      R7,R7,R2
   \   00000020   0x443E             ADD      R6,R6,R7
   \   00000022   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000024   0xF836 0x6013      LDRH     R6,[R6, R3, LSL #+1]
   \   00000028   0x5DA6             LDRB     R6,[R4, R6]
   \   0000002A   0x54EE             STRB     R6,[R5, R3]
    259                   image[i][j + 1] = *(p + gl_RowCol[i][j + 1]);
   \   0000002C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002E   0x2580             MOVS     R5,#+128
   \   00000030   0xFB05 0xF502      MUL      R5,R5,R2
   \   00000034   0x440D             ADD      R5,R1,R5
   \   00000036   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000038   0x441D             ADD      R5,R5,R3
   \   0000003A   0x....             LDR.N    R6,??DataTable9_11
   \   0000003C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003E   0xF44F 0x7780      MOV      R7,#+256
   \   00000042   0xFB07 0xF702      MUL      R7,R7,R2
   \   00000046   0x443E             ADD      R6,R6,R7
   \   00000048   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004A   0xEB06 0x0643      ADD      R6,R6,R3, LSL #+1
   \   0000004E   0x8876             LDRH     R6,[R6, #+2]
   \   00000050   0x5DA6             LDRB     R6,[R4, R6]
   \   00000052   0x706E             STRB     R6,[R5, #+1]
    260                   image[i][j + 2] = *(p + gl_RowCol[i][j + 2]);
   \   00000054   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000056   0x2580             MOVS     R5,#+128
   \   00000058   0xFB05 0xF502      MUL      R5,R5,R2
   \   0000005C   0x440D             ADD      R5,R1,R5
   \   0000005E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000060   0x441D             ADD      R5,R5,R3
   \   00000062   0x....             LDR.N    R6,??DataTable9_11
   \   00000064   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000066   0xF44F 0x7780      MOV      R7,#+256
   \   0000006A   0xFB07 0xF702      MUL      R7,R7,R2
   \   0000006E   0x443E             ADD      R6,R6,R7
   \   00000070   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000072   0xEB06 0x0643      ADD      R6,R6,R3, LSL #+1
   \   00000076   0x88B6             LDRH     R6,[R6, #+4]
   \   00000078   0x5DA6             LDRB     R6,[R4, R6]
   \   0000007A   0x70AE             STRB     R6,[R5, #+2]
    261                   image[i][j + 3] = *(p + gl_RowCol[i][j + 3]);
   \   0000007C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007E   0x2580             MOVS     R5,#+128
   \   00000080   0xFB05 0xF502      MUL      R5,R5,R2
   \   00000084   0x440D             ADD      R5,R1,R5
   \   00000086   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000088   0x441D             ADD      R5,R5,R3
   \   0000008A   0x....             LDR.N    R6,??DataTable9_11
   \   0000008C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008E   0xF44F 0x7780      MOV      R7,#+256
   \   00000092   0xFB07 0xF702      MUL      R7,R7,R2
   \   00000096   0x443E             ADD      R6,R6,R7
   \   00000098   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000009A   0xEB06 0x0643      ADD      R6,R6,R3, LSL #+1
   \   0000009E   0x88F6             LDRH     R6,[R6, #+6]
   \   000000A0   0x5DA6             LDRB     R6,[R4, R6]
   \   000000A2   0x70EE             STRB     R6,[R5, #+3]
    262                }
   \   000000A4   0x1D1B             ADDS     R3,R3,#+4
   \                     ??Img_Compress_128x64_2: (+1)
   \   000000A6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A8   0x2B80             CMP      R3,#+128
   \   000000AA   0xDBAD             BLT.N    ??Img_Compress_128x64_1
   \   000000AC   0x1C52             ADDS     R2,R2,#+1
   \                     ??Img_Compress_128x64_0: (+1)
   \   000000AE   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000B0   0x2A40             CMP      R2,#+64
   \   000000B2   0xDA0A             BGE.N    ??Img_Compress_128x64_3
   \   000000B4   0x....             LDR.N    R3,??DataTable9_12
   \   000000B6   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000B8   0xF833 0x3012      LDRH     R3,[R3, R2, LSL #+1]
   \   000000BC   0xF44F 0x74A0      MOV      R4,#+320
   \   000000C0   0x4363             MULS     R3,R4,R3
   \   000000C2   0xEB00 0x0403      ADD      R4,R0,R3
   \   000000C6   0x2300             MOVS     R3,#+0
   \   000000C8   0xE7ED             B.N      ??Img_Compress_128x64_2
    263             }
    264          }
   \                     ??Img_Compress_128x64_3: (+1)
   \   000000CA   0xBCF0             POP      {R4-R7}
   \   000000CC   0x4770             BX       LR               ;; return
    265          
    266          ////均匀提取
    267          //void ImgCompress_128x64(uint8 *src, uint8 (*image)[IMAGE_WIDTH])
    268          //{
    269          //   register uint16 i, j, tmp1;
    270          //   const uint8 *p = NULL;//位置指针
    271          //   uint16 row = 0;
    272          //   uint16 col = 0;
    273          //   
    274          //   for (i = 0; i < IMAGE_HEIGHT; i++)//图像上下左右颠倒
    275          //   {
    276          //      tmp1 = IMAGE_HEIGHT - i - 1;
    277          //      row = ROW_START + i * ROW_NUM / IMAGE_HEIGHT;
    278          //      p = src + row * CAMERA_W;//位置指针移动
    279          //      for (j = 0; j < IMAGE_WIDTH; j++)//为程序效率考虑，内循环适当展开
    280          //      {
    281          //         col = COLUMN_START + j * COLUMN_NUM / IMAGE_WIDTH;
    282          //         image[tmp1][IMAGE_WIDTH - j - 1] = *(p + col);
    283          //      }
    284          //   }
    285          //}
    286          
    287          //中断函数

   \                                 In section .text, align 4, keep-with-next
    288          void Camera_H_Isr()//行中断
    289          {
    290             if ((H_PORT->ISFR & H_PIN) != 0)//注意优先级，该句话滤掉杂波，必不可少
   \                     Camera_H_Isr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_13  ;; 0x4004b0a0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0480             LSLS     R0,R0,#+18
   \   00000006   0xD505             BPL.N    ??Camera_H_Isr_0
    291             {
    292                LPLD_DMA_EnableReq(DMA_CHX);//开启DMA传输
   \   00000008   0x....             LDR.N    R0,??DataTable9_9  ;; 0x4000800c
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000010   0x....             LDR.N    R1,??DataTable9_9  ;; 0x4000800c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    293             }
    294          }
   \                     ??Camera_H_Isr_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    295          

   \                                 In section .text, align 4, keep-with-next
    296          void Camera_V_Isr()//场中断
    297          {
   \                     Camera_V_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    298             if ((V_PORT->ISFR & V_PIN) != 0)//注意优先级，该句话滤掉杂波，必不可少
   \   00000002   0x....             LDR.N    R0,??DataTable9_13  ;; 0x4004b0a0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0340             LSLS     R0,R0,#+13
   \   00000008   0xD519             BPL.N    ??Camera_V_Isr_0
    299             {
    300                disable_irq(V_PORT_IRQn);
   \   0000000A   0x2059             MOVS     R0,#+89
   \   0000000C   0x.... 0x....      BL       NVIC_DisableIRQ
    301                SoftIsr_Open(Reserved110_IRQn);//触发中断，该中断函数结束后立即进入图像处理
   \   00000010   0x205E             MOVS     R0,#+94
   \   00000012   0x.... 0x....      BL       SoftIsr_Open
    302                if (gl_now_flag == 0)
   \   00000016   0x....             LDR.N    R0,??DataTable9_14
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD106             BNE.N    ??Camera_V_Isr_1
    303                {
    304                   LPLD_DMA_LoadDstAddr(DMA_CHX, (uint32)gl_Image1);
   \   0000001E   0x....             LDR.N    R0,??DataTable9_15
   \   00000020   0x....             LDR.N    R1,??DataTable9_16  ;; 0x40009010
   \   00000022   0x6008             STR      R0,[R1, #+0]
    305                   gl_now_flag = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable9_14
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0xE005             B.N      ??Camera_V_Isr_2
    306                }
    307                else
    308                {
    309                   LPLD_DMA_LoadDstAddr(DMA_CHX, (uint32)gl_Image0);//重新加载目的地址
   \                     ??Camera_V_Isr_1: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable9_8
   \   0000002E   0x....             LDR.N    R1,??DataTable9_16  ;; 0x40009010
   \   00000030   0x6008             STR      R0,[R1, #+0]
    310                   gl_now_flag = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable9_14
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    311                }
    312                enable_irq(V_PORT_IRQn);
   \                     ??Camera_V_Isr_2: (+1)
   \   00000038   0x2059             MOVS     R0,#+89
   \   0000003A   0x.... 0x....      BL       NVIC_EnableIRQ
    313             }
    314          }
   \                     ??Camera_V_Isr_0: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    315          

   \                                 In section .text, align 2, keep-with-next
    316          void Camera_Process_Isr()
    317          {
   \                     Camera_Process_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    318             //图像解压提取,约占4.2ms
    319             if (gl_now_flag == 0)
   \   00000002   0x....             LDR.N    R0,??DataTable9_14
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD106             BNE.N    ??Camera_Process_Isr_0
    320             {
    321                Img_Extract(gl_Image1, gl_ImageFull, CAMERA_SIZE);//解压图像
   \   0000000A   0xF44F 0x5216      MOV      R2,#+9600
   \   0000000E   0x....             LDR.N    R1,??DataTable9_17
   \   00000010   0x....             LDR.N    R0,??DataTable9_15
   \   00000012   0x.... 0x....      BL       Img_Extract
   \   00000016   0xE005             B.N      ??Camera_Process_Isr_1
    322             }
    323             else
    324             {
    325                Img_Extract(gl_Image0, gl_ImageFull, CAMERA_SIZE);//解压图像
   \                     ??Camera_Process_Isr_0: (+1)
   \   00000018   0xF44F 0x5216      MOV      R2,#+9600
   \   0000001C   0x....             LDR.N    R1,??DataTable9_17
   \   0000001E   0x....             LDR.N    R0,??DataTable9_8
   \   00000020   0x.... 0x....      BL       Img_Extract
    326             }
    327             Img_Compress_128x64(gl_ImageFull, gl_ImageCompress);//提取压缩
   \                     ??Camera_Process_Isr_1: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_18
   \   00000026   0x....             LDR.N    R0,??DataTable9_17
   \   00000028   0x.... 0x....      BL       Img_Compress_128x64
    328             
    329             //图像处理
    330             Image(gl_ImageCompress);
   \   0000002C   0x....             LDR.N    R0,??DataTable9_18
   \   0000002E   0x.... 0x....      BL       Image
    331             //待补充
    332          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    333          

   \                                 In section .text, align 2, keep-with-next
    334          void Reserved110_IRQHandler()
    335          {
   \                     Reserved110_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    336             Camera_Process_Isr();
   \   00000002   0x.... 0x....      BL       Camera_Process_Isr
    337          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x00090012         DC32     0x90012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x00020012         DC32     0x20012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     `Camera_DMA_Init::DMA_init`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x400FF0D0         DC32     0x400ff0d0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     gl_Image0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4000800C         DC32     0x4000800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     gl_running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     gl_RowCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     gl_row

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     gl_now_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     gl_Image1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x40009010         DC32     0x40009010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     gl_ImageFull

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x........         DC32     gl_ImageCompress

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Camera_Close
         8   -> NVIC_DisableIRQ
      48   Camera_DMA_Init
        32   -> LPLD_DMA_Init
        48   -> __aeabi_memcpy4
      48   Camera_GPIO_Init
        32   -> LPLD_GPIO_Init
        48   -> __aeabi_memcpy4
       0   Camera_H_Isr
       8   Camera_Init
         8   -> Camera_DMA_Init
         8   -> Camera_GPIO_Init
         8   -> Matrix_Init
         8   -> ov7725_eagle_init
       8   Camera_Process_Isr
         8   -> Image
         8   -> Img_Compress_128x64
         8   -> Img_Extract
       8   Camera_Start
         8   -> NVIC_EnableIRQ
       8   Camera_V_Isr
         8   -> NVIC_DisableIRQ
         8   -> NVIC_EnableIRQ
         8   -> SoftIsr_Open
      16   Img_Compress_128x64
       4   Img_Extract
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   Reserved110_IRQHandler
         8   -> Camera_Process_Isr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      28  Camera_Close
     112  Camera_DMA_Init
     210  Camera_GPIO_Init
      22  Camera_H_Isr
      20  Camera_Init
      52  Camera_Process_Isr
      28  Camera_Start
      64  Camera_V_Isr
      44  DMA_init
     206  Img_Compress_128x64
     240  Img_Extract
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
       8  Reserved110_IRQHandler
    9600  gl_Image0
    9600  gl_Image1
    8192  gl_ImageCompress
   76800  gl_ImageFull
   16384  gl_RowCol
       1  gl_now_flag
     128  gl_row
       1  gl_running

 
 120 750 bytes in section .bss
   1 110 bytes in section .text
 
   1 110 bytes of CODE memory
 120 750 bytes of DATA memory

Errors: none
Warnings: 15
