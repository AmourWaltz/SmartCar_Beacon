###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       27/Jul/2018  20:43:47
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\driver\src\GPT.c
#    Command line =  
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\driver\src\GPT.c" -D LPLD_K60 -lCN
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\iar\FLASH\List"
#        -lB "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\FLASH\List" -o
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\iar\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\app\" -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\CPU\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\common\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\LPLD\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\LPLD\HW\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\LPLD\DEV\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\uCOS-II\Ports\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\uCOS-II\Source\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\FatFs\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\FatFs\option\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\USB\common\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\USB\driver\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\USB\descriptor\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\USB\class\" -I
#        "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\..\..\..\lib\LPLD\FUNC\" -I
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\driver\inc\"
#        -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\driver\src\" -I
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\control\inc\"
#        -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\control\src\" -I
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\debug\inc\"
#        -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\debug\src\" -I
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\device\src\"
#        -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\device\inc\" -I
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\signal\inc\"
#        -I "D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\app\signal\src\" -I
#        "D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\system\" -Ol
#        -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\FLASH\List\GPT.lst
#    Object file  =  
#        D:\Freescale\信标\Beacon_C1
#        -NXP\project\Beacon_XBY\iar\FLASH\Obj\GPT.o
#
###############################################################################

D:\Freescale\信标\Beacon_C1 -NXP\project\Beacon_XBY\app\driver\src\GPT.c
      1          #include "include.h"
      2          

   \                                 In section .bss, align 4
      3          static FTM_InitTypeDef   QD_DECODER;
   \                     QD_DECODER:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
      4          static LPTMR_InitTypeDef PLACC_DECODER;
   \                     PLACC_DECODER:
   \   00000000                      DS8 12
      5          
      6          /**************C车双编码器***************/
      7          

   \                                 In section .text, align 2, keep-with-next
      8          void GPT_Init(void)
      9          {
   \                     GPT_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     10              QD_DECODER_GPT_Init(&QD_DECODER);
   \   00000002   0x....             LDR.N    R0,??DataTable5
   \   00000004   0x.... 0x....      BL       QD_DECODER_GPT_Init
     11              PLACC_DECODER_GPT_Init(&PLACC_DECODER);
   \   00000008   0x....             LDR.N    R0,??DataTable5_1
   \   0000000A   0x.... 0x....      BL       PLACC_DECODER_GPT_Init
     12          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
     13          

   \                                 In section .text, align 2, keep-with-next
     14          void QD_DECODER_GPT_Init(FTM_InitTypeDef *setinfo)
     15          {
   \                     QD_DECODER_GPT_Init: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     16              setinfo->FTM_Ftmx = QD_DECODER_FTM;
   \   00000002   0x....             LDR.N    R1,??DataTable5_2  ;; 0x400b8000
   \   00000004   0x6001             STR      R1,[R0, #+0]
     17              setinfo->FTM_Mode = FTM_MODE_QD;     //正交解码模式
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x7101             STRB     R1,[R0, #+4]
     18              setinfo->FTM_QdMode = QD_MODE_CNTDIR;//QD_MODE_PHAB; 
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x7481             STRB     R1,[R0, #+18]
     19              
     20              LPLD_FTM_Init(*setinfo);
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xB084             SUB      SP,SP,#+16
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x221C             MOVS     R2,#+28
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000001A   0xBC0F             POP      {R0-R3}
   \   0000001C   0x.... 0x....      BL       LPLD_FTM_Init
     21              LPLD_FTM_QD_Enable(QD_DECODER_FTM, QD_DECODER_FTM_PHA_PIN, QD_DECODER_FTM_PHB_PIN);   //AB两相输入端口
   \   00000020   0x2233             MOVS     R2,#+51
   \   00000022   0x2132             MOVS     R1,#+50
   \   00000024   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b8000
   \   00000026   0x.... 0x....      BL       LPLD_FTM_QD_Enable
     22              LPLD_FTM_ClearCounter(QD_DECODER_FTM);//清零  
   \   0000002A   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b8000
   \   0000002C   0x.... 0x....      BL       LPLD_FTM_ClearCounter
     23          }
   \   00000030   0xBD07             POP      {R0-R2,PC}       ;; return
     24          

   \                                 In section .text, align 2, keep-with-next
     25          int16 QD_GPT_cnv(void)
     26          {
   \                     QD_GPT_cnv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     27              int16 num = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     28              
     29              num = LPLD_FTM_GetCounter(QD_DECODER_FTM);
   \   00000004   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b8000
   \   00000006   0x.... 0x....      BL       LPLD_FTM_GetCounter
   \   0000000A   0x0004             MOVS     R4,R0
     30              
     31              LPLD_FTM_ClearCounter(QD_DECODER_FTM);
   \   0000000C   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b8000
   \   0000000E   0x.... 0x....      BL       LPLD_FTM_ClearCounter
     32          
     33              return (num*2);
   \   00000012   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000014   0x0060             LSLS     R0,R4,#+1
   \   00000016   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     34              
     35          }
     36          

   \                                 In section .text, align 2, keep-with-next
     37          void PLACC_DECODER_GPT_Init(LPTMR_InitTypeDef *setinfo)   
     38          {
   \                     PLACC_DECODER_GPT_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     39              setinfo->LPTMR_Mode = LPTMR_MODE_PLACC;  //脉冲累加模式   
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7001             STRB     R1,[R0, #+0]
     40              setinfo->LPTMR_PluseAccInput = ENCODER_LPTMR_CH; //PTC5
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x7101             STRB     R1,[R0, #+4]
     41          
     42              LPLD_LPTMR_Init(*setinfo);
   \   0000000A   0xC807             LDM      R0,{R0-R2}
   \   0000000C   0x.... 0x....      BL       LPLD_LPTMR_Init
     43              
     44              PLACC_DECODER_DIR_GPIO_INIT();
   \   00000010   0x.... 0x....      BL       PLACC_DECODER_DIR_GPIO_INIT
     45          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void PLACC_DECODER_DIR_GPIO_INIT(void)
     48          {
   \                     PLACC_DECODER_DIR_GPIO_INIT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     49              GPIO_Init(PLACC_DECODER_DIR_PORT, PLACC_DECODER_DIR_PIN_MASK, DIR_INPUT, OUTPUT_L); 
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000000A   0x....             LDR.N    R0,??DataTable5_3  ;; 0x400ff040
   \   0000000C   0x.... 0x....      BL       GPIO_Init
     50          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
     51          

   \                                 In section .text, align 2, keep-with-next
     52          int16 PLACC_GPT_cnv(void)
     53          {
   \                     PLACC_GPT_cnv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     54              int16 num = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     55          	
     56              num = -LPLD_LPTMR_GetCounter();
   \   00000004   0x.... 0x....      BL       LPLD_LPTMR_GetCounter
   \   00000008   0x4244             RSBS     R4,R0,#+0
     57              
     58              LPLD_LPTMR_ClearCounter();
   \   0000000A   0x.... 0x....      BL       LPLD_LPTMR_ClearCounter
     59              
     60          //    LPLD_LPTMR_Init(PLACC_DECODER);
     61          
     62              return num;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     63              
     64              //return num*2;
     65          }
     66          
     67          //形式函数

   \                                 In section .text, align 2, keep-with-next
     68          int16 LPLD_LPTMR_GetCounter()
     69          {
   \                     LPLD_LPTMR_GetCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     70              int16 num = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     71              uint8 u8DirLevel;    
     72              
     73              num = LPLD_LPTMR_GetPulseAcc();
   \   00000004   0x.... 0x....      BL       LPLD_LPTMR_GetPulseAcc
   \   00000008   0x0004             MOVS     R4,R0
     74              
     75              u8DirLevel = LPLD_GPIO_Input_b(PLACC_DECODER_DIR_PORT, PLACC_DECODER_DIR_PIN);
   \   0000000A   0x2116             MOVS     R1,#+22
   \   0000000C   0x....             LDR.N    R0,??DataTable5_3  ;; 0x400ff040
   \   0000000E   0x.... 0x....      BL       LPLD_GPIO_Input_b
     76              if (u8DirLevel == BACKWARD_DIR_LV)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??LPLD_LPTMR_GetCounter_0
     77              {
     78                  num = -num;
   \   00000018   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000001A   0x4264             RSBS     R4,R4,#+0
     79              }
     80              
     81              return num;
   \                     ??LPLD_LPTMR_GetCounter_0: (+1)
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     82          }
     83          //形式函数

   \                                 In section .text, align 2, keep-with-next
     84          void LPLD_LPTMR_ClearCounter()
     85          {
   \                     LPLD_LPTMR_ClearCounter: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     86              LPLD_LPTMR_ResetCounter();
   \   00000002   0x.... 0x....      BL       LPLD_LPTMR_ResetCounter
     87              PLACC_DECODER_GPT_Init(&PLACC_DECODER);       
   \   00000006   0x....             LDR.N    R0,??DataTable5_1
   \   00000008   0x.... 0x....      BL       PLACC_DECODER_GPT_Init
     88          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     QD_DECODER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     PLACC_DECODER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x400B8000         DC32     0x400b8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x400FF040         DC32     0x400ff040

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPT_Init
         8   -> PLACC_DECODER_GPT_Init
         8   -> QD_DECODER_GPT_Init
       8   LPLD_LPTMR_ClearCounter
         8   -> LPLD_LPTMR_ResetCounter
         8   -> PLACC_DECODER_GPT_Init
       8   LPLD_LPTMR_GetCounter
         8   -> LPLD_GPIO_Input_b
         8   -> LPLD_LPTMR_GetPulseAcc
       8   PLACC_DECODER_DIR_GPIO_INIT
         8   -> GPIO_Init
       8   PLACC_DECODER_GPT_Init
         8   -> LPLD_LPTMR_Init
         8   -> PLACC_DECODER_DIR_GPIO_INIT
       8   PLACC_GPT_cnv
         8   -> LPLD_LPTMR_ClearCounter
         8   -> LPLD_LPTMR_GetCounter
      32   QD_DECODER_GPT_Init
        16   -> LPLD_FTM_ClearCounter
        16   -> LPLD_FTM_Init
        16   -> LPLD_FTM_QD_Enable
        32   -> __aeabi_memcpy4
       8   QD_GPT_cnv
         8   -> LPLD_FTM_ClearCounter
         8   -> LPLD_FTM_GetCounter


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
      16  GPT_Init
      14  LPLD_LPTMR_ClearCounter
      34  LPLD_LPTMR_GetCounter
      12  PLACC_DECODER
      18  PLACC_DECODER_DIR_GPIO_INIT
      22  PLACC_DECODER_GPT_Init
      20  PLACC_GPT_cnv
      28  QD_DECODER
      50  QD_DECODER_GPT_Init
      26  QD_GPT_cnv

 
  40 bytes in section .bss
 216 bytes in section .text
 
 216 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
